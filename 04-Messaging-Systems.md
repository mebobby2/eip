# Messaging Systems
Messaging makes applications loosely coupled by communicating asynchronously, which also makes the communication more reliable because the two applications do not have to be running at the same time. Messaging makes the messaging system responsible for transferring data from one application to another, so the applications can focus on what data they need to share but not worry so much about how to share it.

## Basic Messaging Concepts
Channels — Messaging applications transmit data through a Message Channel, a virtual pipe that connects a sender to a receiver. A newly installed messaging system doesn’t contain any channels; you must determine how your applications need to communicate and then create the channels to facilitate it.

Messages — A Message is an atomic packet of data that can be transmitted on a channel. The message system will try repeatedly to deliver the message (e.g., transmit it from the sender to the receiver) until it succeeds.

Multi-step delivery — In the simplest case, the message system delivers a message directly from the sender’s computer to the receiver’s computer. However, actions often need to be performed on the message after it is sent by its original sender but before it is received by its final receiver. For example, the message may have to be validated or transformed because the receiver expects a different message format than the sender. A Pipes and Filters architecture describes how multiple processing steps can be chained together using channels.

Routing — In a large enterprise with numerous applications and channels to connect them, a message may have to go through several channels to reach its final destination. The route a message must follow may be so complex that the original sender does not know what channel will get the message to the final receiver. Instead, the original sender sends the message to a Message Router, an application component and filter in the pipes-and-filters architecture, which will determine how to navigate the channel topology and direct the message to the final receiver, or at least to the next router.

Transformation — Various applications may not agree on the format for the same conceptual data; the sender formats the message one way, yet the receiver expects it to be formatted another way. To reconcile this, the message must go through an intermediate filter, a Message Translator, that converts the message from one format to another.

Endpoints — An application does not have some built-in capability to interface with a messaging system. Rather, it must contain a layer of code that knows both how the application works and how the messaging system works, bridging the two so that they work together. This bridge code is a set of coordinated Message Endpoints that enable the application to send and receive messages.

## Message Channel
When an application has information to communicate, it doesn't just fling the information into the messaging system, it adds the information to a particular *Message Channel*. An application receiving information doesn't just pick it up at random from the messaging system; it retrieves the information from a particular *Message Channel*.

Channels are logical addresses in the messaging system; how they're actually implemented depends on the messaging system product and its implementation. A messaging system doesn't automatically come preconfigured with all of the message channels the applications need to communicate. Rather, the developers designing the applications and the communication between them have to decide what channels will be needed for the communication. The number and purpose of channels available tend to be fixed at deployment time.

Channels are cheap, but they're not free. Each channel requires memory to represent the messages; persistent channels require disk space as well.

There are two different kinds of message channels, *Point-to-Point Channels* and *Publish-Subscribe Channels*. Mixing different data types on the same channel causes a lot of confusion; to avoid this confusion, use separate *Datatype Channels*. Applications that use messaging often benefit from a special channel for invalid messages, an *Invalid Message Channel*. Applications that wish to use *Messaging* but do not have access to a messaging client can still connect to the messaging system using *Channel Adapters*. A well designed set of channels forms a *Message Bus* that acts like a messaging API for a whole group of applications.

## Message
What does it mean to "transmit" data? In a function call, the caller can pass a parameter by reference by passing a pointer to the data's address in memory; this works because both the caller and the function share the same memory heap. Similarly, two threads in the same process can pass a record or object by passing a pointer, since they both share the same memory space.

Two separate processes passing a piece of data have more work to do. Since they each have their own memory space, they have to copy the data from one memory space to the other. The data is usually transmitted as a byte stream, the most basic form of data, which means that the first process must marshal the data into byte form, copy it from the first process to the second one, which will then unmarshal the data back into its original form, a copy of the original data in the first process. Marshalling is how an RPC sends arguments to the remote process, and how the process returns the result.

Any data that is to be transmitted via a messaging system must be converted into one or more messages that can be sent through messaging channels.

A message consists of two basic parts:
1. Header - Information used by the messaging system that describes the data being transmitted, its origin, its destination, and so on.
2. Body - The data being transmitted; generally ignored by the messaging system and simply transmitted as-is.

Use a Command Message to invoke a procedure in another application. Use a Document Message to pass a set of data to another application. Use an Event Message to notify another application of a change in this application. If the other application should send a reply back, use Request-Reply.

If an application wishes to send more information than one message can hold, break the data into smaller parts and send the parts as a Message Sequence. If the data is only useful for a limited amount of time, specify this use-by time as a Message Expiration. Since all the various senders and receivers of messages must agree on the format of the data in the messages, specify the format as a Canonical Data Model.

## Pipes and Filters
Integration solutions are typically a collection of heterogeneous systems. As a result, different processing steps may need to execute on different physical machines, for example because individual processing steps can only execute on a specific systems. For example, it is possible that the private key required to decrypt incoming messages is only available on a designated machine and cannot be accessed from any other machine for security reasons. This means that the decryption component has to execute on this designated machine while the other steps may execute on other machines. Likewise, different processing steps may be implemented using different programming languages or technologies that prevent them from running inside the same process or even on the same computer.

Use the Pipes and Filters architectural style to divide a larger processing task into a sequence of smaller, independent processing steps (Filters) that are connected by channels (Pipes).

Each filter exposes a very simple interface: it receives messages on the inbound pipe, processes the message, and publishes the results to the outbound pipe. The pipe connects one filter to the next, sending output messages from one filter to the next. Because all component use the same external interface they can be composed into different solutions by connecting the components to different pipes. We can add new filters, omit existing ones or rearrange them into a new sequence -- all without having to change the filters themselves. The connection between filter and pipe is sometimes called port. In the basic form, each filter component has one input port and one output port.

The pipe allows one component to send a message into the pipe so that it can be consumed later by another process that is unknown to the component. The obvious implementation for such a pipe is the Message Channel.

Using Pipes and Filters improves testability, an often overlooked benefit. We can test each individual processing steps by passing a Test Message to the component and comparing the results to the expected outcome.

One of the potential downsides of a Pipes and Filters architecture is the larger number of required channels. First, channels may not be an unlimited resource as channels provide buffering and other functions that consume memory and CPU cycles. Also, publishing a message to a channel involves a certain amount of overhead because the data has to be translated from the application-internal format into the messaging infrastructure's own format. At the receiving end this process has to be reversed. If we are using a long chain of filters, we are paying for the gain in flexibility with potentially lower performance due to repeated message data conversion.

Pipes and Filters share some similarities with the concept of Communicating Sequential Processes (CSPs). CSPs provide a simple model to describe synchronization problems that occur in parallel processing systems. The basic mechanism underlying CSPs is the synchronization of two processes via input-output (I/O). I/O occurs when process A indicates that it is ready to output to process B, and process B states that it is ready to input from process A. If one of these happens without the other being true, the process is put on a wait queue until the other process is ready. CSPs are different from integration solutions in that they are not as loosely coupled, nor do the "pipes" provide any queuing mechanisms.

### Pipeline Processing
When a unit has completed processing one message it can send the message to the output channel and immediately start processing another message. It does not have to wait for the subsequent components to read and process the message. This allows multiple messages to be processed concurrently as they pass through the individual stages. We call such a configuration a processing pipeline because messages flow through the filters like liquid flows through a pipe. When compared to strictly sequential processing, a processing pipeline can significantly increase system throughput.

### Parallel Processing
However, the overall system throughput is limited by the slowest process in the chain. To improve throughput we can deploy multiple parallel instances of that process to improve throughput. In this scenario, a Point-to-Point Channel with Competing Consumers is needed to guarantee that each message on the channel is consumed by exactly one of N available processors. This allows us to speed up the most time-intensive process and improve overall throughput. However, this configuration can cause messages to be processed out of order. If the sequence of messages is critical, we can only run one instance of each component or use a Resequencer.

Parallelizing filters works best if each filter is stateless, i.e. it returns to the previous state after a message has been processed. This means that we cannot easily run multiple parallel de-dup components because the component maintains a history of all messages that it already received and is therefore not stateless.

## Message Router
Message-based integration solutions deal with individual messages which are not necessarily associated with a single, larger data set. As a result, individual messages are more likely to require a different series of processing steps.

A Message Channel decouples the sender and the receiver of a Message. This means that multiple applications can publish Messages to a Message Channel. As a result, a message channel can contain messages from different sources that may have to be treated differently based on the type of the message or other criteria. You could create a separate Message Channel for each message type (a concept explained in more detail later as a Datatype Channel) and connect each channel to the required processing steps for that message type. However, this would require the message originators to be aware of the selection criteria for different processing steps, so that they can publish the message to the correct channel. It could also lead to an explosion of the number of Message Channels. Also, the decision on which steps the message undergoes may not just depend on the origin of the message. For example, we could imagine a situation where the destination of a message changes by the number of messages that have passed through the channel so far. No single originator would know this number and would therefore be unable to send the message to the correct channel.

An application publishes a Message to a Message Channel and has no further knowledge of that Message's destination. Therefore, the path of the Message can change depending on which component subscribes to the Message Channel. However, this type of 'routing' does not take into account the properties of individual messages. Once a components subscribes to a Message Channel it will by default consume all messages from that channel regardless of the individual messages' specific properties. We could solve this problem by making the receiving component itself responsible for determining whether it should process the message or not. This is problematic, though, because once the message is consumed and the component determines that it does not want the message it can't just put the message back on the channel for another component to check out. Some messaging systems allow receivers to inspect message properties without removing the message from the channel so that it can decide whether to consume the message or not. However, this is not a general solution and will also tie the consuming component to a specific type of message because the logic for message selection is now built right into the component. This would reduce the potential for reuse of that component and eliminate the composability that is the key strength of the Pipes and Filters model.

Insert a special filter, a Message Router, which consumes a Message from one Message Channel and republishes it to a different Message Channel channel depending on a set of conditions. The Message Router differs from the most basic notion of Pipes and Filters in that it connects to multiple output channels. Thanks to the Pipes and Filters architecture the components surrounding the Message Router are completely unaware of the existence of a Message Router. A key property of the Message Router is that it does not modify the message contents. It only concerns itself with the destination of the message.

The key benefit of using a Message Router is that the decision criteria for the destination of a message are maintained in a single location. If new message types are defined, new processing components are added, or the routing rules change, we need to change only the Message Router logic and all other components remain unaffected. Also, since all messages pass through a single Message Router, incoming messages are guaranteed to be processed one-by-one in the correct order.

While the intent of a Message Router is to decouple filters, using a Message Router can actually cause the opposite effect. The Message Router needs to have knowledge of all possible message destinations in order to send the message to the correct channel. In some situations, the list of possible destinations may change frequently and turn the Message Router into a maintenance bottleneck. In those cases, it would be better to let the individual recipients decide which messages they are interested in. You can accomplish this by using a Publish-Subscribe Channel and an array of Message Filters. We contrast these two alternatives by calling them predictive routing and reactive filtering.

Because a Message Router requires the insertion of an additional processing step it can degrade performance. Many message-based systems have to decode the message from one channel before it can be placed on another channel, which causes computational overhead if the message itself does not really change. This overhead can turn a Message Router, into a performance bottleneck. By using multiple routers in parallel or adding additional hardware, this effect can be minimized. As a result, the message throughput (number of messages processed per time unit) may not be impacted, but the latency (time for one message to travel through the system) will almost certainly increase.

Deliberate use of Message Routers can turn the advantage of loose coupling into a disadvantage. Loosely coupled systems can make it difficult to understand the "big picture" of the solution, i.e. the overall flow of messages through the system. This is a common problem with messaging solutions and the use of routers can exacerbate the problem. If everything is loosely coupled to everything else it becomes impossible to understand which way messages actually flow. This can complicate testing and debugging and maintenance. A number of tools can help alleviate this problem. First, we can use the Message History to inspect messages at runtime and see which components they traversed. Alternatively, we can compile a list of all channels that each component in the system subscribes or publishes to. With this knowledge we can draw a graph of all possible message flows across components. Many EAI packages maintain channel subscription information in a central repository, making this type of static analysis easier.

### Message Router Variants
A Message Router can use any number of criteria to determine the output channel for an incoming message. The most trivial case is a fixed router. In this case, only a single input channel and a single output channel are defined. In most cases, a fixed router will be combined with a Message Translator or a Channel Adapter to transform the message content or send the message over a different channel type.

Many Message Routers decide the message destination only on properties of the message itself, for example the message type or the values of specific message fields. We call such a router a Content-Based Router.

Other Message Routers decide the message's destination based on environment conditions. We call these routers Context-Based Routers. Such routers are commonly used to perform load balancing, test or failover functionality. For example, if a processing component fails, the Context-Based Router can re-route message to another processing component and thus provide fail-over capability. Other routers split messages evenly across multiple channels to achieve parallel processing similar to a load balancer. A Message Channel already provides basic load balancing capabilities without the use of a Message Router because multiple competing consumers can each consume messages off the same channel as fast as they can. However, a Message Router can have additional built-in intelligence to route the messages as opposed to a simple round-robin implemented by the channel.

Many Message Routers are stateless, i.e. they only look at one message at a time to make the routing decision. Other routers take the content of previous messages into account when making a routing decision. For example, we can envision a router that eliminates duplicate messages by keeping a list of all messages it already received. These routers are stateful.

Most Message Routers contain hard-coded logic for the routing decision. However, some variants connect to a Control Bus so that the middleware solution can change the decision criteria without having to make any code changes or interrupting the flow of messages. For example, the Control Bus can propagate the value of a global variable to all Message Routers in the system. This can be very useful for testing to allow the messaging system to switch from 'test' to 'production' mode. The Dynamic Router configures itself dynamically based on control messages from each potential recipient.

### Example: Commercial EAI Tools
The notion of a Message Router is central to the concept of a Message Broker. These tools accept incoming messages, validate them, transform them and route them to the correct destination. This architecture alleviates the participating applications from having to be aware of other applications altogether because the message broker brokers between the applications. This is a key function in EAI because most applications to be connected are packaged or legacy applications and the integration has to happen non-intrusively, i.e. without changing the application code. This requires the middleware to incorporate all routing logic so the applications do not have to. The Message Broker is the integration equivalent of a Mediator presented in Gang Of Four.

## Message Translator
In many cases, enterprise integration solutions route messages between existing applications such as legacy systems, packaged applications, homegrown custom applications, or applications operated by external partners. Each of these applications is usually built around a proprietary data model. Each application may have a slightly different notion of the Customer entity , the attributes that define a Customer and which other entities a Customer is related to. For example, the accounting system may be more interested in the customer's tax payer ID numbers while the customer-relationship management (CRM) system stores phone numbers and addresses. The application’s underlying data model usually drives the design of the physical database schema, an interface file format or a programming interface (API) -- those entities that an integration solution has to interface with. As a result, the applications expect to receive messages that mimic the application's internal data format.

We could avoid having to transform messages if we could modify all applications to use a common data format. This turns out to be difficult for a number of reasons. First, changing an application’s data format is risky, difficult, and requires a lot of changes to inherent business functionality. For most legacy applications, data format changes are simply not economically feasible.

Furthermore, if we adjust the data format of one application to match that of another application we are tying the two applications more tightly to each other. One of the key architectural principles in enterprise integration is loose coupling between applications. Modifying one application to match another application's data format would violate this principle because it makes two applications directly dependent on each other's internal representation. This eliminates the possibility of replacing or changing one application without affecting the other application, a scenario that is fairly common in enterprise integration.

Use a special filter, a Message Translator, between other filters or applications to translate one data format into another. The Message Translator is the messaging equivalent of the Adapter pattern described in GoF.

### Levels of Transformation
| Layer        | Deals With           | Transformation Needs (Example) | Tools / Techniques |
| ------------- |:-------------:| -----:| --------: |
| Application Layer      | Entities, associations, cardinality | Condense many-to-many relationship into aggregation. | Structural Mapping, Patterns, Custom code |
| Data Types      | Field names, data types, value domains, constraints, code values      | Convert zip code from numeric to string. Concatenate first name and last name fields to single name field. Replace US state name with two character code. | EAI visual transformation editor, XSL, Database lookups, Custom code |
| Data Representation | Data formats (XML, name-value pairm EAI vendor formats). Character sets (ASCII, UniCode, EBCDIC). Encryption / compression       | Parse data representation and render in a different format. Decrypt/ encrypt as necessary. | XML Parsers, EAI parser / renderer tools Custom APIs |
Transport| Communications Protocols:TCP/IP sockets, http, SOAP, JMS, TIBCO RendezVous | Move data across protocols without affecting message content. | Channel Adapter, EAI adapters |

### Levels of Decoupling
Many of the design trade-offs in integration are driven by the need to decouple components or applications. Decoupling is an essential tool to enable the management of change.  Integration typically connects existing applications and has to accommodate changes to these applications. Message Channels decouple applications from having to know each other's location. A Message Router can even decouple applications from having to agree on a common Message Router. However, this form of decoupling only achieves limited independence between applications if they depend on each other's data formats. A Message Translator can help remove this level of dependency .

##  Message Endpoint
